package com.tw;
/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;

import java.io.ByteArrayOutputStream;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class LibraryTest {
    @Mock
    private Input mockInput;

    @Mock
    private Output mockOutput;

    private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();

    public Student getStudent1(){
        Map<String, Double> map = new HashMap<>();
        Student student = new Student("张三","201801",map);
        map.put("语文",90.0);
        map.put("数学",80.0);
        return student;
    }

    public Student getStudent2(){
        Map<String, Double> map = new HashMap<>();
        Student student = new Student("李四","201802",map);

        map.put("语文",90.0);
        map.put("数学",80.0);
        return student;
    }

    @Test
    public void should_input_is_digit() throws Exception {
        Mockito.when(mockInput.readInput()).thenReturn("1A");
        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        assertFalse(library.checkForSelectNumber("1A"));

    }

    @Test
    public void should_select_exit() throws Exception {
        Mockito.when(mockInput.readInput()).thenReturn("3");

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        library.func();
        assertTrue(library.checkForSelectNumber("3"));
        Mockito.verify(mockOutput,Mockito.times(1)).outputMainPage();
    }

    @Test
    public void should_student_info_not_format() throws Exception {

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        assertFalse(library.formatCheckForStudentInfo("张三,201801"));

    }

    @Test
    public void should_student_info_is_format() throws Exception {

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        assertTrue(library.formatCheckForStudentInfo("张三,201801,语文:100,数学:80"));

    }

    @Test
    public void should_add_one_student_fail() throws Exception {

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        assertFalse(library.addOneStudent("张三,201801,语文:100,数学:80.0.0"));
    }

    @Test
    public void should_add_one_student_success() throws Exception {

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        assertTrue(library.addOneStudent("张三,201801,语文:100,数学:80"));
    }

    @Test
    public void should_add_one_student() throws Exception {
        Mockito.when(mockInput.readInput()).thenReturn("张三,201801,语文:100,数学:80");
        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        library.addStudentFunc();
        assertTrue(library.formatCheckForStudentInfo("张三,201801,语文:100,数学:80"));
        assertTrue(library.addOneStudent("张三,201801,语文:100,数学:80"));
    }

    @Test
    public void should_student_number_is_format() throws Exception {

        Library library = new Library(mockInput,mockOutput,new ArrayList<>());
        String[] numbers= {"201801","201802"};
        assertEquals(library.formatCheckForStudentNumber("201801,201802"),numbers);

    }

    @Test
    public void should_find_student_by_number() throws Exception {

        List<Student> students = new ArrayList<>();
        students.add(getStudent1());
        students.add(getStudent2());

        Mockito.when(mockInput.readInput()).thenReturn("201801");

        Library library = new Library(mockInput,mockOutput,students);

        assertEquals(library.findStudent(students,"201801"),getStudent1());
        assertEquals(library.findStudent(students,"201802"),getStudent2());
    }

    @Test
    public void testSomeLibraryMethod() {
        Library classUnderTest = new Library();
        assertTrue("someLibraryMethod should return 'true'", classUnderTest.someLibraryMethod());
    }

    @Test
    public void testMockClass() throws Exception {
        // you can mock concrete classes, not only interfaces
        LinkedList mockedList = mock(LinkedList.class);

        // stubbing appears before the actual execution
        String value = "first";
        when(mockedList.get(0)).thenReturn(value);

        assertEquals(mockedList.get(0), value);

    }

}
